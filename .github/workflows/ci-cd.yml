name: AutoScoring CI/CD

on:
  push:
    branches: ["main", "master"]
  pull_request:
    branches: ["main", "master"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  test:
    name: Test (Python 3.11)
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest==8.3.5

      - name: Run tests
        env:
          FLASK_TESTING: "1"
        run: |
          python -m pytest tests -v --tb=short

  deploy_cpu:
    name: Deploy to VPS (CPU)
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    environment: autoscore
    timeout-minutes: 25
    concurrency:
      group: production-deploy
      cancel-in-progress: true

    steps:
      - name: Validate deploy secrets
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PROJECT_PATH: ${{ secrets.VPS_PROJECT_PATH }}
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
          VPS_KNOWN_HOSTS: ${{ secrets.VPS_KNOWN_HOSTS }}
        run: |
          missing=0
          for name in VPS_HOST VPS_USER VPS_PROJECT_PATH VPS_SSH_KEY VPS_KNOWN_HOSTS; do
            if [ -z "${!name}" ]; then
              echo "Missing required secret: ${name}"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "One or more deploy secrets are missing in environment 'autoscore'."
            exit 1
          fi

      - name: Configure SSH
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh

          # Accept one of the following VPS_SSH_KEY formats:
          # 1) Full OpenSSH private key text (BEGIN/END, multiline)
          # 2) Base64 of the full key file content
          # 3) OpenSSH payload body only (starts with b3BlbnNzaC1rZXkt...)
          raw_key='${{ secrets.VPS_SSH_KEY }}'
          normalized="$(printf '%s' "${raw_key}" | perl -pe 's/\\n/\n/g' | tr -d '\r')"
          compact="$(printf '%s' "${normalized}" | tr -d '\n\t ')"

          if printf '%s' "${normalized}" | grep -q 'BEGIN OPENSSH PRIVATE KEY'; then
            # Format 1: already armored key text
            printf '%s' "${normalized}" > ~/.ssh/id_ed25519
          elif printf '%s' "${compact}" | grep -Eq '^b3BlbnNzaC1rZXktdjE'; then
            # Format 3: payload body only -> re-armour
            {
              echo '-----BEGIN OPENSSH PRIVATE KEY-----'
              printf '%s' "${compact}" | fold -w 70
              echo '-----END OPENSSH PRIVATE KEY-----'
            } > ~/.ssh/id_ed25519
          else
            # Try format 2: base64 of full key file
            decoded_file="$(mktemp)"
            if ! printf '%s' "${compact}" | base64 -d > "${decoded_file}" 2>/dev/null; then
              echo "Invalid VPS_SSH_KEY. Use full OpenSSH key text, base64 of full key file, or OpenSSH payload body."
              rm -f "${decoded_file}"
              exit 1
            fi

            if grep -q 'BEGIN OPENSSH PRIVATE KEY' "${decoded_file}"; then
              cat "${decoded_file}" > ~/.ssh/id_ed25519
            else
              # Decoded binary payload (openssh-key-v1) -> re-armour it
              magic_hex="$(xxd -p -l 14 "${decoded_file}" 2>/dev/null || true)"
              if [ "${magic_hex}" = "6f70656e7373682d6b65792d7631" ]; then
                payload_b64="$(base64 -w 0 "${decoded_file}")"
                {
                  echo '-----BEGIN OPENSSH PRIVATE KEY-----'
                  printf '%s' "${payload_b64}" | fold -w 70
                  echo '-----END OPENSSH PRIVATE KEY-----'
                } > ~/.ssh/id_ed25519
              else
                echo "Invalid VPS_SSH_KEY decoded content."
                rm -f "${decoded_file}"
                exit 1
              fi
            fi
            rm -f "${decoded_file}"
          fi

          chmod 600 ~/.ssh/id_ed25519

          # Validate key format early to avoid opaque SSH/libcrypto errors.
          if ! ssh-keygen -y -f ~/.ssh/id_ed25519 > /dev/null 2>&1; then
            echo "Invalid VPS_SSH_KEY format. Use an unencrypted private key (OpenSSH PEM) with original multiline format."
            exit 1
          fi

          printf '%s\n' "${{ secrets.VPS_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Deploy on server
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PROJECT_PATH: ${{ secrets.VPS_PROJECT_PATH }}
        run: |
          set -euo pipefail

          DEPLOY_PATH="${VPS_PROJECT_PATH}"
          if [ "${DEPLOY_PATH#/}" = "${DEPLOY_PATH}" ]; then
            echo "VPS_PROJECT_PATH harus absolute path (contoh: /home/deploy/AutoScoring)"
            exit 1
          fi

          ssh \
            -i ~/.ssh/id_ed25519 \
            -o IdentitiesOnly=yes \
            -o PreferredAuthentications=publickey \
            -o BatchMode=yes \
            -o ConnectTimeout=20 \
            -o StrictHostKeyChecking=yes \
            "${VPS_USER}@${VPS_HOST}" /bin/bash -s -- "${DEPLOY_PATH}" "${GITHUB_SHA}" <<'REMOTE_SCRIPT'
            set -euo pipefail

            DEPLOY_PATH="$1"
            TARGET_SHA="$2"

            cd "${DEPLOY_PATH}"
            git fetch --prune origin
            git checkout --force "${TARGET_SHA}"
            git clean -fdx -e .env -e data/ -e logs/ -e results/ -e uploads/

            if [ ! -f .env ]; then
              echo "File .env tidak ditemukan di server (${DEPLOY_PATH}). Deploy dibatalkan."
              exit 1
            fi

            if ! grep -Eq '^SECRET_KEY=.+' .env; then
              echo "SECRET_KEY belum diisi di .env server. Deploy dibatalkan."
              exit 1
            fi

            docker compose --env-file .env -f docker-compose.cpu.yml up -d --build --remove-orphans
            docker compose -f docker-compose.cpu.yml ps
          REMOTE_SCRIPT

  notify_discord:
    name: Notify Discord
    runs-on: ubuntu-latest
    environment: autoscore
    needs: [test, deploy_cpu]
    if: always()

    steps:
      - name: Send Discord notification
        shell: bash
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TEST_RESULT: ${{ needs.test.result }}
          DEPLOY_RESULT: ${{ needs.deploy_cpu.result }}
          REPOSITORY: ${{ github.repository }}
          BRANCH: ${{ github.ref_name }}
          REF: ${{ github.ref }}
          ACTOR: ${{ github.actor }}
          RUN_ID: ${{ github.run_id }}
          RUN_NUMBER: ${{ github.run_number }}
          RUN_ATTEMPT: ${{ github.run_attempt }}
          RUN_STARTED_AT: ${{ github.run_started_at }}
          WORKFLOW_NAME: ${{ github.workflow }}
          COMMIT_SHA: ${{ github.sha }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          set -euo pipefail

          if [ -z "${DISCORD_WEBHOOK_URL}" ]; then
            echo "DISCORD_WEBHOOK_URL secret is not set, skipping notification."
            exit 0
          fi

          SHORT_SHA="${COMMIT_SHA::7}"
          RUN_URL="https://github.com/${REPOSITORY}/actions/runs/${RUN_ID}"
          COMMIT_URL="https://github.com/${REPOSITORY}/commit/${COMMIT_SHA}"

          if [ "${TEST_RESULT}" = "success" ] && { [ "${DEPLOY_RESULT}" = "success" ] || [ "${DEPLOY_RESULT}" = "skipped" ]; }; then
            STATUS="SUCCESS"
            ICON=":white_check_mark:"
            COLOR=3066993
          else
            STATUS="FAILED"
            ICON=":x:"
            COLOR=15158332
          fi

          if [ "${DEPLOY_RESULT}" = "skipped" ]; then
            DEPLOY_LABEL="skipped (expected for non-push or non-main/master)"
          else
            DEPLOY_LABEL="${DEPLOY_RESULT}"
          fi

          if [ "${TEST_RESULT}" != "success" ]; then
            FAILURE_REASON="Tests failed or were cancelled"
          elif [ "${DEPLOY_RESULT}" = "failure" ] || [ "${DEPLOY_RESULT}" = "cancelled" ] || [ "${DEPLOY_RESULT}" = "timed_out" ]; then
            FAILURE_REASON="Deployment failed"
          elif [ "${DEPLOY_RESULT}" = "skipped" ]; then
            FAILURE_REASON="Deploy skipped by branch/event rule"
          else
            FAILURE_REASON="All critical stages passed"
          fi

          MESSAGE="${ICON} AutoScoring CI/CD ${STATUS}"
          TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

          ELAPSED="N/A"
          if [ -n "${RUN_STARTED_AT}" ]; then
            start_epoch="$(date -u -d "${RUN_STARTED_AT}" +%s 2>/dev/null || true)"
            now_epoch="$(date -u +%s)"
            if [ -n "${start_epoch}" ]; then
              elapsed_sec=$((now_epoch - start_epoch))
              if [ "${elapsed_sec}" -lt 60 ]; then
                ELAPSED="${elapsed_sec}s"
              else
                ELAPSED="$((elapsed_sec / 60))m $((elapsed_sec % 60))s"
              fi
            fi
          fi

          if ! PAYLOAD="$(jq -n \
            --arg message "${MESSAGE}" \
            --arg repository "${REPOSITORY}" \
            --arg branch "${BRANCH}" \
            --arg event_name "${EVENT_NAME}" \
            --arg test_result "${TEST_RESULT}" \
            --arg deploy_result "${DEPLOY_LABEL}" \
            --arg actor "${ACTOR}" \
            --arg commit "${SHORT_SHA}" \
            --arg commit_url "${COMMIT_URL}" \
            --arg run_url "${RUN_URL}" \
            --arg workflow_name "${WORKFLOW_NAME}" \
            --arg run_number "${RUN_NUMBER}" \
            --arg run_attempt "${RUN_ATTEMPT}" \
            --arg elapsed "${ELAPSED}" \
            --arg failure_reason "${FAILURE_REASON}" \
            --arg ref "${REF}" \
            --arg timestamp "${TIMESTAMP}" \
            --argjson color "${COLOR}" \
            '{
              embeds: [
                {
                  title: $message,
                  description: $failure_reason,
                  color: $color,
                  fields: [
                    {name: "Workflow", value: $workflow_name, inline: true},
                    {name: "Run", value: ("#" + $run_number + " (attempt " + $run_attempt + ")"), inline: true},
                    {name: "Duration", value: $elapsed, inline: true},
                    {name: "Repository", value: $repository, inline: true},
                    {name: "Branch", value: $branch, inline: true},
                    {name: "Event", value: $event_name, inline: true},
                    {name: "Test", value: $test_result, inline: true},
                    {name: "Deploy", value: $deploy_result, inline: true},
                    {name: "Actor", value: $actor, inline: true},
                    {name: "Ref", value: $ref, inline: false},
                    {name: "Commit", value: ("[`" + $commit + "`]" + "(" + $commit_url + ")"), inline: true},
                    {name: "Links", value: ("[Open workflow run](" + $run_url + ")"), inline: false}
                  ],
                  timestamp: $timestamp
                }
              ]
            }')"; then
            echo "Failed to build Discord payload; continuing without notification."
            exit 0
          fi

          if ! curl --fail-with-body -sS -X POST "${DISCORD_WEBHOOK_URL}" \
            -H "Content-Type: application/json" \
            --retry 3 --retry-delay 2 \
            -d "${PAYLOAD}"; then
            echo "Discord notification failed; continuing workflow."
            exit 0
          fi
